version: '3'

services:
  # =========================
  # MySQL
  # =========================
  mysql:
    image: mysql:8.0
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=root
      - MYSQL_USER=application
      - MYSQL_PASSWORD=application
      - MYSQL_DATABASE=hhplus
    volumes:
      - ./data/mysql/:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "mysql"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app-net

  # =========================
  # Spring App
  # =========================
  spring-app:
    build:
      context: . # 빌드 컨텍스트를 프로젝트 루트 디렉토리로 변경
      dockerfile: ./docker/spring-app/Dockerfile # Dockerfile의 경로를 명시
    image: hhplus-e-commerce
    ports:
      - "8080:8080"
    depends_on:
      mysql:
        condition: service_healthy
      redis-master:
        condition: service_started
      kafka:
        condition: service_started
    environment:
      SPRING_PROFILES_ACTIVE: docker
    networks:
      - app-net

  # =========================
  # Redis Master
  # =========================
  redis-master:
    image: redis:latest
    ports:
      - "6379:6379"
    command: redis-server
    networks:
      - app-net

  # =========================
  # Redis Replica
  # =========================
  redis-replica-1:
    image: redis:latest
    ports:
      - "6380:6380"
    command: redis-server --replicaof redis-master 6379
    links:
      - redis-master
    networks:
      - app-net

  redis-replica-2:
    image: redis:latest
    ports:
      - "6381:6381"
    command: redis-server --replicaof redis-master 6379
    links:
      - redis-master
    networks:
      - app-net

  # =========================
  # Redis Sentinels
  # =========================
  sentinel-1:
    build:
      context: ./docker/sentinel
      dockerfile: Dockerfile
    ports:
      - "26379:26379"
    env_file:
      - .env
    depends_on:
      - redis-master
      - redis-replica-1
      - redis-replica-2
    networks:
      - app-net

  sentinel-2:
    build:
      context: ./docker/sentinel
      dockerfile: Dockerfile
    ports:
      - "26380:26379"
    env_file:
      - .env
    depends_on:
      - redis-master
      - redis-replica-1
      - redis-replica-2
    networks:
      - app-net

  sentinel-3:
    build:
      context: ./docker/sentinel
      dockerfile: Dockerfile
    ports:
      - "26381:26379"
    env_file:
      - .env
    depends_on:
      - redis-master
      - redis-replica-1
      - redis-replica-2
    networks:
      - app-net

  # =========================
  # Kafka (KRaft 모드)
  # =========================
  kafka:
    image: bitnami/kafka:3.7.0
    container_name: kafka
    ports:
      - "9092:9092"   # 호스트(localhost) 접근용
      - "29092:29092" # 도커 내부 네트워크 접근용
    environment:
      # -------------------- KRaft 모드 --------------------
      - KAFKA_ENABLE_KRAFT=yes                # Zookeeper 없이 KRaft 모드 실행
      - KAFKA_CFG_NODE_ID=1                   # 노드 ID (단일 노드라서 1)
      - KAFKA_CFG_PROCESS_ROLES=broker,controller
      # 이 노드가 Broker + Controller 역할 모두 수행
      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka:29093
      # Controller 합의 그룹 (단일 노드라서 1개만 등록)
      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
      # Controller는 CONTROLLER Listener를 사용

      # -------------------- Listener 설정 --------------------
      # 29092 → 내부 컨테이너 간 통신
      # 9092 → 로컬 호스트(localhost)에서 접근
      # 29093 → KRaft Controller 내부 통신
      - KAFKA_CFG_LISTENERS=PLAINTEXT://:29092,PLAINTEXT_HOST://:9092,CONTROLLER://:29093
      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092
      # 컨테이너 내부에서는 kafka:29092 로 접근
      # 호스트 PC에서는 localhost:9092 로 접근
      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      # 모든 Listener를 PLAINTEXT(암호화 없음)으로 지정
      - KAFKA_CFG_INTER_BROKER_LISTENER_NAME=PLAINTEXT
      # 브로커 간 통신 시 사용할 Listener 지정

      # -------------------- 토픽 & 트랜잭션 설정 --------------------
      - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true
      # 없는 토픽에 publish 요청 시 자동 생성
      - KAFKA_CFG_NUM_PARTITIONS=3
      # 기본 파티션 개수 (토픽 생성 시)
      - KAFKA_CFG_OFFSETS_TOPIC_REPLICATION_FACTOR=1
      # consumer group offset 저장용 토픽 복제본 수 (단일 브로커 → 1)
      - KAFKA_CFG_TRANSACTION_STATE_LOG_REPLICATION_FACTOR=1
      # 트랜잭션 로그 복제본 수 (단일 브로커 → 1)
      - KAFKA_CFG_TRANSACTION_STATE_LOG_MIN_ISR=1
      # 트랜잭션 로그 최소 ISR (단일 브로커 → 1)

    volumes:
      - kafka_data:/bitnami/kafka
      # Kafka 데이터 영구 저장 (컨테이너 재시작해도 데이터 유지)

    networks:
      - app-net

  # =========================
  # Kafka Connect
  # =========================
  connect:
    image: debezium/connect:2.5
    container_name: kafka-connect
    ports:
      - "8083:8083"
    environment:
      BOOTSTRAP_SERVERS: kafka:29092
      GROUP_ID: 1
      CONFIG_STORAGE_TOPIC: connect-configs
      OFFSET_STORAGE_TOPIC: connect-offsets
      STATUS_STORAGE_TOPIC: connect-status
      KEY_CONVERTER: org.apache.kafka.connect.json.JsonConverter
      VALUE_CONVERTER: org.apache.kafka.connect.json.JsonConverter
      VALUE_CONVERTER_SCHEMAS_ENABLE: "false"
      CONNECT_ERRORS_DEADLETTERQUEUE_TOPIC_NAME: dlq-outbox
      CONNECT_ERRORS_DEADLETTERQUEUE_CONTEXT_HEADERS_ENABLE: "true"
    volumes:
      - ./src/main/resources/kr/hhplus/be/server/config:/kafka/connectors
    depends_on:
      mysql:
        condition: service_healthy
      kafka:
        condition: service_started
    networks:
      - app-net
# =========================
# 네트워크 & 볼륨 정의
# =========================
networks:
  app-net:
    driver: bridge

volumes:
  kafka_data:
    driver: local